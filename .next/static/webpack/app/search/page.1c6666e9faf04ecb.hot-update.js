"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/search/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOrder: function() { return /* binding */ createOrder; },\n/* harmony export */   getCategories: function() { return /* binding */ getCategories; },\n/* harmony export */   getCategoryBySlug: function() { return /* binding */ getCategoryBySlug; },\n/* harmony export */   getDailyBestSellers: function() { return /* binding */ getDailyBestSellers; },\n/* harmony export */   getFeaturedProducts: function() { return /* binding */ getFeaturedProducts; },\n/* harmony export */   getOrderByNumber: function() { return /* binding */ getOrderByNumber; },\n/* harmony export */   getProductBySlug: function() { return /* binding */ getProductBySlug; },\n/* harmony export */   getProducts: function() { return /* binding */ getProducts; },\n/* harmony export */   getTopProducts: function() { return /* binding */ getTopProducts; },\n/* harmony export */   getUserOrders: function() { return /* binding */ getUserOrders; },\n/* harmony export */   searchProducts: function() { return /* binding */ searchProducts; }\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/constants */ \"(app-pages-browser)/./src/lib/constants.ts\");\n\n\n// ============================================\n// MOCK DATA (Used when Supabase is not configured)\n// ============================================\nconst mockCategories = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CATEGORIES.map((cat, index)=>({\n        id: \"cat-\".concat(cat.id),\n        name: cat.name,\n        slug: cat.slug,\n        icon: cat.icon,\n        item_count: cat.itemCount,\n        sort_order: index,\n        is_active: true,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n    }));\n// ============================================\n// CATEGORY API\n// ============================================\n/**\n * Get all categories\n */ async function getCategories() {\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        return mockCategories;\n    }\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"categories\").select(\"*\").eq(\"is_active\", true).order(\"sort_order\");\n        if (error) throw error;\n        // Add item_count from products\n        const categoriesWithCount = await Promise.all((data || []).map(async (cat)=>{\n            const { count } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"products\").select(\"*\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"category_id\", cat.id).eq(\"is_available\", true);\n            return {\n                ...cat,\n                item_count: count || 0\n            };\n        }));\n        return categoriesWithCount;\n    } catch (error) {\n        console.error(\"Error fetching categories:\", error);\n        return mockCategories;\n    }\n}\n/**\n * Get category by slug\n */ async function getCategoryBySlug(slug) {\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        return mockCategories.find((cat)=>cat.slug === slug) || null;\n    }\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"categories\").select(\"*\").eq(\"slug\", slug).eq(\"is_active\", true).single();\n        if (error) throw error;\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching category:\", error);\n        return mockCategories.find((cat)=>cat.slug === slug) || null;\n    }\n}\n// ============================================\n// PRODUCT API\n// ============================================\n/**\n * Get products with optional filters\n */ async function getProducts(filters) {\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        return filterMockProducts(filters);\n    }\n    try {\n        let query = _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"products\").select(\"\\n        *,\\n        category:categories(id, name, slug, icon)\\n      \");\n        // Apply filters\n        if (filters === null || filters === void 0 ? void 0 : filters.categorySlug) {\n            const category = await getCategoryBySlug(filters.categorySlug);\n            if (category) {\n                query = query.eq(\"category_id\", category.id);\n            }\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.search) {\n            query = query.ilike(\"name\", \"%\".concat(filters.search, \"%\"));\n        }\n        if ((filters === null || filters === void 0 ? void 0 : filters.isAvailable) !== undefined) {\n            query = query.eq(\"is_available\", filters.isAvailable);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.isFeatured) {\n            query = query.eq(\"is_featured\", true);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.badge) {\n            query = query.eq(\"badge\", filters.badge);\n        }\n        if ((filters === null || filters === void 0 ? void 0 : filters.minPrice) !== undefined) {\n            query = query.gte(\"price\", filters.minPrice);\n        }\n        if ((filters === null || filters === void 0 ? void 0 : filters.maxPrice) !== undefined) {\n            query = query.lte(\"price\", filters.maxPrice);\n        }\n        // Sorting\n        switch(filters === null || filters === void 0 ? void 0 : filters.sortBy){\n            case \"price_asc\":\n                query = query.order(\"price\", {\n                    ascending: true\n                });\n                break;\n            case \"price_desc\":\n                query = query.order(\"price\", {\n                    ascending: false\n                });\n                break;\n            case \"name\":\n                query = query.order(\"name\", {\n                    ascending: true\n                });\n                break;\n            case \"rating\":\n                query = query.order(\"rating\", {\n                    ascending: false,\n                    nullsFirst: false\n                });\n                break;\n            default:\n                query = query.order(\"created_at\", {\n                    ascending: false\n                });\n        }\n        // Pagination\n        if (filters === null || filters === void 0 ? void 0 : filters.limit) {\n            query = query.limit(filters.limit);\n        }\n        if (filters === null || filters === void 0 ? void 0 : filters.offset) {\n            query = query.range(filters.offset, filters.offset + (filters.limit || 20) - 1);\n        }\n        const { data, error } = await query;\n        if (error) throw error;\n        return data || [];\n    } catch (error) {\n        console.error(\"Error fetching products:\", error);\n        return filterMockProducts(filters);\n    }\n}\n// Helper function to filter mock products\nfunction filterMockProducts(filters) {\n    let products = [\n        ...mockProducts\n    ];\n    if (filters === null || filters === void 0 ? void 0 : filters.categorySlug) {\n        const categoryIndex = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CATEGORIES.findIndex((cat)=>cat.slug === filters.categorySlug);\n        if (categoryIndex !== -1) {\n            products = products.filter((p)=>p.category_id === \"cat-\".concat(categoryIndex + 1));\n        }\n    }\n    if (filters === null || filters === void 0 ? void 0 : filters.search) {\n        const searchLower = filters.search.toLowerCase();\n        products = products.filter((p)=>p.name.toLowerCase().includes(searchLower));\n    }\n    if ((filters === null || filters === void 0 ? void 0 : filters.isAvailable) !== undefined) {\n        products = products.filter((p)=>p.is_available === filters.isAvailable);\n    }\n    if (filters === null || filters === void 0 ? void 0 : filters.isFeatured) {\n        products = products.filter((p)=>p.is_featured);\n    }\n    if (filters === null || filters === void 0 ? void 0 : filters.badge) {\n        products = products.filter((p)=>p.badge === filters.badge);\n    }\n    // Sorting\n    switch(filters === null || filters === void 0 ? void 0 : filters.sortBy){\n        case \"price_asc\":\n            products.sort((a, b)=>a.price - b.price);\n            break;\n        case \"price_desc\":\n            products.sort((a, b)=>b.price - a.price);\n            break;\n        case \"name\":\n            products.sort((a, b)=>a.name.localeCompare(b.name));\n            break;\n        case \"rating\":\n            products.sort((a, b)=>(b.rating || 0) - (a.rating || 0));\n            break;\n    }\n    // Pagination\n    if (filters === null || filters === void 0 ? void 0 : filters.limit) {\n        const offset = filters.offset || 0;\n        products = products.slice(offset, offset + filters.limit);\n    }\n    return products;\n}\n/**\n * Get product by slug\n */ async function getProductBySlug(slug) {\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        return mockProducts.find((p)=>p.slug === slug) || null;\n    }\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"products\").select(\"\\n        *,\\n        category:categories(id, name, slug, icon)\\n      \").eq(\"slug\", slug).single();\n        if (error) throw error;\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching product:\", error);\n        return mockProducts.find((p)=>p.slug === slug) || null;\n    }\n}\n/**\n * Search products\n */ async function searchProducts(query) {\n    return getProducts({\n        search: query\n    });\n}\n/**\n * Get featured products\n */ async function getFeaturedProducts() {\n    return getProducts({\n        isFeatured: true,\n        limit: 10\n    });\n}\n/**\n * Get daily best sellers\n */ async function getDailyBestSellers() {\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        return mockProducts.filter((p)=>p.badge === \"hot\" || p.badge === \"best-seller\" || p.badge === \"popular\").slice(0, 4);\n    }\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"products\").select(\"*\").in(\"badge\", [\n            \"hot\",\n            \"best-seller\",\n            \"popular\"\n        ]).eq(\"is_available\", true).limit(4);\n        if (error) throw error;\n        return data || [];\n    } catch (error) {\n        console.error(\"Error fetching best sellers:\", error);\n        return mockProducts.filter((p)=>p.badge === \"hot\" || p.badge === \"best-seller\").slice(0, 4);\n    }\n}\n/**\n * Get top products grouped by type\n */ async function getTopProducts() {\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        const sortedByRating = [\n            ...mockProducts\n        ].sort((a, b)=>(b.rating || 0) - (a.rating || 0));\n        const sortedByReviews = [\n            ...mockProducts\n        ].sort((a, b)=>(b.review_count || 0) - (a.review_count || 0));\n        return {\n            topSells: sortedByReviews.slice(0, 3),\n            topRated: sortedByRating.slice(0, 3),\n            trending: mockProducts.filter((p)=>p.badge === \"hot\" || p.badge === \"popular\").slice(0, 3),\n            recentlyAdded: mockProducts.filter((p)=>p.badge === \"new\").slice(0, 3)\n        };\n    }\n    try {\n        const [topSells, topRated, trending, recentlyAdded] = await Promise.all([\n            _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"products\").select(\"*\").eq(\"is_available\", true).order(\"review_count\", {\n                ascending: false,\n                nullsFirst: false\n            }).limit(3),\n            _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"products\").select(\"*\").eq(\"is_available\", true).order(\"rating\", {\n                ascending: false,\n                nullsFirst: false\n            }).limit(3),\n            _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"products\").select(\"*\").in(\"badge\", [\n                \"hot\",\n                \"popular\"\n            ]).eq(\"is_available\", true).limit(3),\n            _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"products\").select(\"*\").eq(\"badge\", \"new\").eq(\"is_available\", true).limit(3)\n        ]);\n        return {\n            topSells: topSells.data || [],\n            topRated: topRated.data || [],\n            trending: trending.data || [],\n            recentlyAdded: recentlyAdded.data || []\n        };\n    } catch (error) {\n        console.error(\"Error fetching top products:\", error);\n        return {\n            topSells: [],\n            topRated: [],\n            trending: [],\n            recentlyAdded: []\n        };\n    }\n}\n/**\n * Create a new order\n */ async function createOrder(orderData) {\n    const subtotal = orderData.items.reduce((sum, item)=>sum + item.productPrice * item.quantity, 0);\n    const deliveryFee = subtotal >= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DELIVERY_CONFIG.freeDeliveryThreshold ? 0 : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DELIVERY_CONFIG.baseFee;\n    const total = subtotal + deliveryFee;\n    let order;\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        // Return mock order\n        const orderNumber = \"SS-\".concat(new Date().toISOString().slice(2, 10).replace(/-/g, \"\"), \"-\").concat(Math.random().toString(36).substring(2, 6).toUpperCase());\n        order = {\n            id: \"order-\".concat(Date.now()),\n            order_number: orderNumber,\n            customer_name: orderData.customer.name,\n            customer_phone: orderData.customer.phone,\n            customer_address: orderData.customer.address,\n            customer_notes: orderData.customer.notes,\n            status: \"pending\",\n            subtotal,\n            delivery_fee: deliveryFee,\n            total,\n            created_at: new Date().toISOString(),\n            updated_at: new Date().toISOString()\n        };\n    } else {\n        try {\n            // Create order\n            const { data: orderData2, error: orderError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"orders\").insert({\n                customer_name: orderData.customer.name,\n                customer_phone: orderData.customer.phone,\n                customer_address: orderData.customer.address,\n                customer_notes: orderData.customer.notes,\n                status: \"pending\",\n                subtotal,\n                delivery_fee: deliveryFee,\n                total\n            }).select().single();\n            if (orderError) throw orderError;\n            order = orderData2;\n            // Create order items\n            const orderItems = orderData.items.map((item)=>({\n                    order_id: order.id,\n                    product_id: item.productId,\n                    product_name: item.productName,\n                    product_price: item.productPrice,\n                    quantity: item.quantity,\n                    subtotal: item.productPrice * item.quantity\n                }));\n            const { error: itemsError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"order_items\").insert(orderItems);\n            if (itemsError) throw itemsError;\n            // Create payment record\n            const { error: paymentError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"payments\").insert({\n                order_id: order.id,\n                method: orderData.paymentMethod,\n                status: orderData.paymentMethod === \"cod\" ? \"pending\" : \"pending\",\n                amount: total,\n                reference_number: orderData.gcashReference\n            });\n            if (paymentError) throw paymentError;\n        } catch (error) {\n            console.error(\"Error creating order:\", error);\n            throw error;\n        }\n    }\n    // Send email notification (non-blocking)\n    sendOrderNotification({\n        orderNumber: order.order_number,\n        customerName: orderData.customer.name,\n        customerPhone: orderData.customer.phone,\n        customerAddress: orderData.customer.address,\n        customerNotes: orderData.customer.notes,\n        items: orderData.items.map((item)=>({\n                name: item.productName,\n                price: item.productPrice,\n                quantity: item.quantity\n            })),\n        subtotal,\n        deliveryFee,\n        total,\n        paymentMethod: orderData.paymentMethod,\n        gcashReference: orderData.gcashReference\n    }).catch((err)=>console.error(\"Failed to send notification:\", err));\n    return order;\n}\n/**\n * Send order notification email\n */ async function sendOrderNotification(data) {\n    try {\n        const response = await fetch(\"/api/send-order-notification\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to send notification\");\n        }\n        return await response.json();\n    } catch (error) {\n        console.error(\"Notification error:\", error);\n        throw error;\n    }\n}\n/**\n * Get order by order number\n */ async function getOrderByNumber(orderNumber) {\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        return null;\n    }\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"orders\").select(\"\\n        *,\\n        items:order_items(*),\\n        payment:payments(*)\\n      \").eq(\"order_number\", orderNumber).single();\n        if (error) throw error;\n        return data;\n    } catch (error) {\n        console.error(\"Error fetching order:\", error);\n        return null;\n    }\n}\n/**\n * Get user's orders\n */ async function getUserOrders(userId) {\n    if (!(0,_supabase__WEBPACK_IMPORTED_MODULE_0__.isSupabaseConfigured)()) {\n        return [];\n    }\n    try {\n        const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"orders\").select(\"\\n        *,\\n        items:order_items(*),\\n        payment:payments(*)\\n      \").eq(\"user_id\", userId).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) throw error;\n        return data || [];\n    } catch (error) {\n        console.error(\"Error fetching user orders:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VSxRQUFRVixLQUFLLENBQUMsK0JBQStCQTtRQUM3QyxPQUFPLEVBQUU7SUFDWDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpLnRzPzJmYWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UsIGlzU3VwYWJhc2VDb25maWd1cmVkIH0gZnJvbSBcIi4vc3VwYWJhc2VcIjtcbmltcG9ydCB0eXBlIHtcbiAgUHJvZHVjdCxcbiAgQ2F0ZWdvcnksXG4gIFByb2R1Y3RGaWx0ZXJzLFxuICBPcmRlcixcbiAgT3JkZXJJdGVtLFxuICBQYXltZW50TWV0aG9kLFxufSBmcm9tIFwiQC90eXBlc1wiO1xuaW1wb3J0IHsgQ0FURUdPUklFUywgREVMSVZFUllfQ09ORklHIH0gZnJvbSBcIkAvbGliL2NvbnN0YW50c1wiO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTU9DSyBEQVRBIChVc2VkIHdoZW4gU3VwYWJhc2UgaXMgbm90IGNvbmZpZ3VyZWQpXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBtb2NrQ2F0ZWdvcmllczogQ2F0ZWdvcnlbXSA9IENBVEVHT1JJRVMubWFwKChjYXQsIGluZGV4KSA9PiAoe1xuICBpZDogYGNhdC0ke2NhdC5pZH1gLFxuICBuYW1lOiBjYXQubmFtZSxcbiAgc2x1ZzogY2F0LnNsdWcsXG4gIGljb246IGNhdC5pY29uLFxuICBpdGVtX2NvdW50OiBjYXQuaXRlbUNvdW50LFxuICBzb3J0X29yZGVyOiBpbmRleCxcbiAgaXNfYWN0aXZlOiB0cnVlLFxuICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbn0pKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENBVEVHT1JZIEFQSVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBHZXQgYWxsIGNhdGVnb3JpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENhdGVnb3JpZXMoKTogUHJvbWlzZTxDYXRlZ29yeVtdPiB7XG4gIGlmICghaXNTdXBhYmFzZUNvbmZpZ3VyZWQoKSkge1xuICAgIHJldHVybiBtb2NrQ2F0ZWdvcmllcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKFwiY2F0ZWdvcmllc1wiKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImlzX2FjdGl2ZVwiLCB0cnVlKVxuICAgICAgLm9yZGVyKFwic29ydF9vcmRlclwiKTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICAvLyBBZGQgaXRlbV9jb3VudCBmcm9tIHByb2R1Y3RzXG4gICAgY29uc3QgY2F0ZWdvcmllc1dpdGhDb3VudCA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgKGRhdGEgfHwgW10pLm1hcChhc3luYyAoY2F0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oXCJwcm9kdWN0c1wiKVxuICAgICAgICAgIC5zZWxlY3QoXCIqXCIsIHsgY291bnQ6IFwiZXhhY3RcIiwgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAgIC5lcShcImNhdGVnb3J5X2lkXCIsIGNhdC5pZClcbiAgICAgICAgICAuZXEoXCJpc19hdmFpbGFibGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jYXQsXG4gICAgICAgICAgaXRlbV9jb3VudDogY291bnQgfHwgMCxcbiAgICAgICAgfSBhcyBDYXRlZ29yeTtcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICByZXR1cm4gY2F0ZWdvcmllc1dpdGhDb3VudDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgY2F0ZWdvcmllczpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBtb2NrQ2F0ZWdvcmllcztcbiAgfVxufVxuXG4vKipcbiAqIEdldCBjYXRlZ29yeSBieSBzbHVnXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYXRlZ29yeUJ5U2x1ZyhcbiAgc2x1Zzogc3RyaW5nLFxuKTogUHJvbWlzZTxDYXRlZ29yeSB8IG51bGw+IHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCgpKSB7XG4gICAgcmV0dXJuIG1vY2tDYXRlZ29yaWVzLmZpbmQoKGNhdCkgPT4gY2F0LnNsdWcgPT09IHNsdWcpIHx8IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcImNhdGVnb3JpZXNcIilcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAuZXEoXCJzbHVnXCIsIHNsdWcpXG4gICAgICAuZXEoXCJpc19hY3RpdmVcIiwgdHJ1ZSlcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGEgYXMgQ2F0ZWdvcnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGNhdGVnb3J5OlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG1vY2tDYXRlZ29yaWVzLmZpbmQoKGNhdCkgPT4gY2F0LnNsdWcgPT09IHNsdWcpIHx8IG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBST0RVQ1QgQVBJXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEdldCBwcm9kdWN0cyB3aXRoIG9wdGlvbmFsIGZpbHRlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb2R1Y3RzKFxuICBmaWx0ZXJzPzogUHJvZHVjdEZpbHRlcnMsXG4pOiBQcm9taXNlPFByb2R1Y3RbXT4ge1xuICBpZiAoIWlzU3VwYWJhc2VDb25maWd1cmVkKCkpIHtcbiAgICByZXR1cm4gZmlsdGVyTW9ja1Byb2R1Y3RzKGZpbHRlcnMpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZS5mcm9tKFwicHJvZHVjdHNcIikuc2VsZWN0KGBcbiAgICAgICAgKixcbiAgICAgICAgY2F0ZWdvcnk6Y2F0ZWdvcmllcyhpZCwgbmFtZSwgc2x1ZywgaWNvbilcbiAgICAgIGApO1xuXG4gICAgLy8gQXBwbHkgZmlsdGVyc1xuICAgIGlmIChmaWx0ZXJzPy5jYXRlZ29yeVNsdWcpIHtcbiAgICAgIGNvbnN0IGNhdGVnb3J5ID0gYXdhaXQgZ2V0Q2F0ZWdvcnlCeVNsdWcoZmlsdGVycy5jYXRlZ29yeVNsdWcpO1xuICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoXCJjYXRlZ29yeV9pZFwiLCBjYXRlZ29yeS5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcnM/LnNlYXJjaCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5pbGlrZShcIm5hbWVcIiwgYCUke2ZpbHRlcnMuc2VhcmNofSVgKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsdGVycz8uaXNBdmFpbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcShcImlzX2F2YWlsYWJsZVwiLCBmaWx0ZXJzLmlzQXZhaWxhYmxlKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsdGVycz8uaXNGZWF0dXJlZCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcShcImlzX2ZlYXR1cmVkXCIsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXJzPy5iYWRnZSkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcShcImJhZGdlXCIsIGZpbHRlcnMuYmFkZ2UpO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXJzPy5taW5QcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5Lmd0ZShcInByaWNlXCIsIGZpbHRlcnMubWluUHJpY2UpO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXJzPy5tYXhQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5Lmx0ZShcInByaWNlXCIsIGZpbHRlcnMubWF4UHJpY2UpO1xuICAgIH1cblxuICAgIC8vIFNvcnRpbmdcbiAgICBzd2l0Y2ggKGZpbHRlcnM/LnNvcnRCeSkge1xuICAgICAgY2FzZSBcInByaWNlX2FzY1wiOlxuICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKFwicHJpY2VcIiwgeyBhc2NlbmRpbmc6IHRydWUgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByaWNlX2Rlc2NcIjpcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5vcmRlcihcInByaWNlXCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKFwibmFtZVwiLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmF0aW5nXCI6XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkub3JkZXIoXCJyYXRpbmdcIiwgeyBhc2NlbmRpbmc6IGZhbHNlLCBudWxsc0ZpcnN0OiBmYWxzZSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gUGFnaW5hdGlvblxuICAgIGlmIChmaWx0ZXJzPy5saW1pdCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5saW1pdChmaWx0ZXJzLmxpbWl0KTtcbiAgICB9XG5cbiAgICBpZiAoZmlsdGVycz8ub2Zmc2V0KSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LnJhbmdlKFxuICAgICAgICBmaWx0ZXJzLm9mZnNldCxcbiAgICAgICAgZmlsdGVycy5vZmZzZXQgKyAoZmlsdGVycy5saW1pdCB8fCAyMCkgLSAxLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIChkYXRhIHx8IFtdKSBhcyBQcm9kdWN0W107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHByb2R1Y3RzOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIGZpbHRlck1vY2tQcm9kdWN0cyhmaWx0ZXJzKTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZmlsdGVyIG1vY2sgcHJvZHVjdHNcbmZ1bmN0aW9uIGZpbHRlck1vY2tQcm9kdWN0cyhmaWx0ZXJzPzogUHJvZHVjdEZpbHRlcnMpOiBQcm9kdWN0W10ge1xuICBsZXQgcHJvZHVjdHMgPSBbLi4ubW9ja1Byb2R1Y3RzXTtcblxuICBpZiAoZmlsdGVycz8uY2F0ZWdvcnlTbHVnKSB7XG4gICAgY29uc3QgY2F0ZWdvcnlJbmRleCA9IENBVEVHT1JJRVMuZmluZEluZGV4KFxuICAgICAgKGNhdCkgPT4gY2F0LnNsdWcgPT09IGZpbHRlcnMuY2F0ZWdvcnlTbHVnLFxuICAgICk7XG4gICAgaWYgKGNhdGVnb3J5SW5kZXggIT09IC0xKSB7XG4gICAgICBwcm9kdWN0cyA9IHByb2R1Y3RzLmZpbHRlcihcbiAgICAgICAgKHApID0+IHAuY2F0ZWdvcnlfaWQgPT09IGBjYXQtJHtjYXRlZ29yeUluZGV4ICsgMX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmlsdGVycz8uc2VhcmNoKSB7XG4gICAgY29uc3Qgc2VhcmNoTG93ZXIgPSBmaWx0ZXJzLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICAgIHByb2R1Y3RzID0gcHJvZHVjdHMuZmlsdGVyKChwKSA9PlxuICAgICAgcC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoTG93ZXIpLFxuICAgICk7XG4gIH1cblxuICBpZiAoZmlsdGVycz8uaXNBdmFpbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHByb2R1Y3RzID0gcHJvZHVjdHMuZmlsdGVyKChwKSA9PiBwLmlzX2F2YWlsYWJsZSA9PT0gZmlsdGVycy5pc0F2YWlsYWJsZSk7XG4gIH1cblxuICBpZiAoZmlsdGVycz8uaXNGZWF0dXJlZCkge1xuICAgIHByb2R1Y3RzID0gcHJvZHVjdHMuZmlsdGVyKChwKSA9PiBwLmlzX2ZlYXR1cmVkKTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzPy5iYWRnZSkge1xuICAgIHByb2R1Y3RzID0gcHJvZHVjdHMuZmlsdGVyKChwKSA9PiBwLmJhZGdlID09PSBmaWx0ZXJzLmJhZGdlKTtcbiAgfVxuXG4gIC8vIFNvcnRpbmdcbiAgc3dpdGNoIChmaWx0ZXJzPy5zb3J0QnkpIHtcbiAgICBjYXNlIFwicHJpY2VfYXNjXCI6XG4gICAgICBwcm9kdWN0cy5zb3J0KChhLCBiKSA9PiBhLnByaWNlIC0gYi5wcmljZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicHJpY2VfZGVzY1wiOlxuICAgICAgcHJvZHVjdHMuc29ydCgoYSwgYikgPT4gYi5wcmljZSAtIGEucHJpY2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgIHByb2R1Y3RzLnNvcnQoKGEsIGIpID0+IGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJhdGluZ1wiOlxuICAgICAgcHJvZHVjdHMuc29ydCgoYSwgYikgPT4gKGIucmF0aW5nIHx8IDApIC0gKGEucmF0aW5nIHx8IDApKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gUGFnaW5hdGlvblxuICBpZiAoZmlsdGVycz8ubGltaXQpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBmaWx0ZXJzLm9mZnNldCB8fCAwO1xuICAgIHByb2R1Y3RzID0gcHJvZHVjdHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBmaWx0ZXJzLmxpbWl0KTtcbiAgfVxuXG4gIHJldHVybiBwcm9kdWN0cztcbn1cblxuLyoqXG4gKiBHZXQgcHJvZHVjdCBieSBzbHVnXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9kdWN0QnlTbHVnKHNsdWc6IHN0cmluZyk6IFByb21pc2U8UHJvZHVjdCB8IG51bGw+IHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCgpKSB7XG4gICAgcmV0dXJuIG1vY2tQcm9kdWN0cy5maW5kKChwKSA9PiBwLnNsdWcgPT09IHNsdWcpIHx8IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInByb2R1Y3RzXCIpXG4gICAgICAuc2VsZWN0KFxuICAgICAgICBgXG4gICAgICAgICosXG4gICAgICAgIGNhdGVnb3J5OmNhdGVnb3JpZXMoaWQsIG5hbWUsIHNsdWcsIGljb24pXG4gICAgICBgLFxuICAgICAgKVxuICAgICAgLmVxKFwic2x1Z1wiLCBzbHVnKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YSBhcyBQcm9kdWN0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBwcm9kdWN0OlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG1vY2tQcm9kdWN0cy5maW5kKChwKSA9PiBwLnNsdWcgPT09IHNsdWcpIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZWFyY2ggcHJvZHVjdHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlYXJjaFByb2R1Y3RzKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3RbXT4ge1xuICByZXR1cm4gZ2V0UHJvZHVjdHMoeyBzZWFyY2g6IHF1ZXJ5IH0pO1xufVxuXG4vKipcbiAqIEdldCBmZWF0dXJlZCBwcm9kdWN0c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmVhdHVyZWRQcm9kdWN0cygpOiBQcm9taXNlPFByb2R1Y3RbXT4ge1xuICByZXR1cm4gZ2V0UHJvZHVjdHMoeyBpc0ZlYXR1cmVkOiB0cnVlLCBsaW1pdDogMTAgfSk7XG59XG5cbi8qKlxuICogR2V0IGRhaWx5IGJlc3Qgc2VsbGVyc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGFpbHlCZXN0U2VsbGVycygpOiBQcm9taXNlPFByb2R1Y3RbXT4ge1xuICBpZiAoIWlzU3VwYWJhc2VDb25maWd1cmVkKCkpIHtcbiAgICByZXR1cm4gbW9ja1Byb2R1Y3RzXG4gICAgICAuZmlsdGVyKFxuICAgICAgICAocCkgPT5cbiAgICAgICAgICBwLmJhZGdlID09PSBcImhvdFwiIHx8XG4gICAgICAgICAgcC5iYWRnZSA9PT0gXCJiZXN0LXNlbGxlclwiIHx8XG4gICAgICAgICAgcC5iYWRnZSA9PT0gXCJwb3B1bGFyXCIsXG4gICAgICApXG4gICAgICAuc2xpY2UoMCwgNCk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcInByb2R1Y3RzXCIpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmluKFwiYmFkZ2VcIiwgW1wiaG90XCIsIFwiYmVzdC1zZWxsZXJcIiwgXCJwb3B1bGFyXCJdKVxuICAgICAgLmVxKFwiaXNfYXZhaWxhYmxlXCIsIHRydWUpXG4gICAgICAubGltaXQoNCk7XG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIHJldHVybiAoZGF0YSB8fCBbXSkgYXMgUHJvZHVjdFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBiZXN0IHNlbGxlcnM6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gbW9ja1Byb2R1Y3RzXG4gICAgICAuZmlsdGVyKChwKSA9PiBwLmJhZGdlID09PSBcImhvdFwiIHx8IHAuYmFkZ2UgPT09IFwiYmVzdC1zZWxsZXJcIilcbiAgICAgIC5zbGljZSgwLCA0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0b3AgcHJvZHVjdHMgZ3JvdXBlZCBieSB0eXBlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUb3BQcm9kdWN0cygpOiBQcm9taXNlPHtcbiAgdG9wU2VsbHM6IFByb2R1Y3RbXTtcbiAgdG9wUmF0ZWQ6IFByb2R1Y3RbXTtcbiAgdHJlbmRpbmc6IFByb2R1Y3RbXTtcbiAgcmVjZW50bHlBZGRlZDogUHJvZHVjdFtdO1xufT4ge1xuICBpZiAoIWlzU3VwYWJhc2VDb25maWd1cmVkKCkpIHtcbiAgICBjb25zdCBzb3J0ZWRCeVJhdGluZyA9IFsuLi5tb2NrUHJvZHVjdHNdLnNvcnQoXG4gICAgICAoYSwgYikgPT4gKGIucmF0aW5nIHx8IDApIC0gKGEucmF0aW5nIHx8IDApLFxuICAgICk7XG4gICAgY29uc3Qgc29ydGVkQnlSZXZpZXdzID0gWy4uLm1vY2tQcm9kdWN0c10uc29ydChcbiAgICAgIChhLCBiKSA9PiAoYi5yZXZpZXdfY291bnQgfHwgMCkgLSAoYS5yZXZpZXdfY291bnQgfHwgMCksXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3BTZWxsczogc29ydGVkQnlSZXZpZXdzLnNsaWNlKDAsIDMpLFxuICAgICAgdG9wUmF0ZWQ6IHNvcnRlZEJ5UmF0aW5nLnNsaWNlKDAsIDMpLFxuICAgICAgdHJlbmRpbmc6IG1vY2tQcm9kdWN0c1xuICAgICAgICAuZmlsdGVyKChwKSA9PiBwLmJhZGdlID09PSBcImhvdFwiIHx8IHAuYmFkZ2UgPT09IFwicG9wdWxhclwiKVxuICAgICAgICAuc2xpY2UoMCwgMyksXG4gICAgICByZWNlbnRseUFkZGVkOiBtb2NrUHJvZHVjdHMuZmlsdGVyKChwKSA9PiBwLmJhZGdlID09PSBcIm5ld1wiKS5zbGljZSgwLCAzKSxcbiAgICB9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBbdG9wU2VsbHMsIHRvcFJhdGVkLCB0cmVuZGluZywgcmVjZW50bHlBZGRlZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBzdXBhYmFzZVxuICAgICAgICAuZnJvbShcInByb2R1Y3RzXCIpXG4gICAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAgIC5lcShcImlzX2F2YWlsYWJsZVwiLCB0cnVlKVxuICAgICAgICAub3JkZXIoXCJyZXZpZXdfY291bnRcIiwgeyBhc2NlbmRpbmc6IGZhbHNlLCBudWxsc0ZpcnN0OiBmYWxzZSB9KVxuICAgICAgICAubGltaXQoMyksXG4gICAgICBzdXBhYmFzZVxuICAgICAgICAuZnJvbShcInByb2R1Y3RzXCIpXG4gICAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAgIC5lcShcImlzX2F2YWlsYWJsZVwiLCB0cnVlKVxuICAgICAgICAub3JkZXIoXCJyYXRpbmdcIiwgeyBhc2NlbmRpbmc6IGZhbHNlLCBudWxsc0ZpcnN0OiBmYWxzZSB9KVxuICAgICAgICAubGltaXQoMyksXG4gICAgICBzdXBhYmFzZVxuICAgICAgICAuZnJvbShcInByb2R1Y3RzXCIpXG4gICAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAgIC5pbihcImJhZGdlXCIsIFtcImhvdFwiLCBcInBvcHVsYXJcIl0pXG4gICAgICAgIC5lcShcImlzX2F2YWlsYWJsZVwiLCB0cnVlKVxuICAgICAgICAubGltaXQoMyksXG4gICAgICBzdXBhYmFzZVxuICAgICAgICAuZnJvbShcInByb2R1Y3RzXCIpXG4gICAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAgIC5lcShcImJhZGdlXCIsIFwibmV3XCIpXG4gICAgICAgIC5lcShcImlzX2F2YWlsYWJsZVwiLCB0cnVlKVxuICAgICAgICAubGltaXQoMyksXG4gICAgXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wU2VsbHM6ICh0b3BTZWxscy5kYXRhIHx8IFtdKSBhcyBQcm9kdWN0W10sXG4gICAgICB0b3BSYXRlZDogKHRvcFJhdGVkLmRhdGEgfHwgW10pIGFzIFByb2R1Y3RbXSxcbiAgICAgIHRyZW5kaW5nOiAodHJlbmRpbmcuZGF0YSB8fCBbXSkgYXMgUHJvZHVjdFtdLFxuICAgICAgcmVjZW50bHlBZGRlZDogKHJlY2VudGx5QWRkZWQuZGF0YSB8fCBbXSkgYXMgUHJvZHVjdFtdLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHRvcCBwcm9kdWN0czpcIiwgZXJyb3IpO1xuICAgIHJldHVybiB7IHRvcFNlbGxzOiBbXSwgdG9wUmF0ZWQ6IFtdLCB0cmVuZGluZzogW10sIHJlY2VudGx5QWRkZWQ6IFtdIH07XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE9SREVSIEFQSVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuaW50ZXJmYWNlIENyZWF0ZU9yZGVyRGF0YSB7XG4gIGN1c3RvbWVyOiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHBob25lOiBzdHJpbmc7XG4gICAgYWRkcmVzczogc3RyaW5nO1xuICAgIG5vdGVzPzogc3RyaW5nO1xuICB9O1xuICBwYXltZW50TWV0aG9kOiBQYXltZW50TWV0aG9kO1xuICBnY2FzaFJlZmVyZW5jZT86IHN0cmluZztcbiAgaXRlbXM6IEFycmF5PHtcbiAgICBwcm9kdWN0SWQ6IHN0cmluZztcbiAgICBwcm9kdWN0TmFtZTogc3RyaW5nO1xuICAgIHByb2R1Y3RQcmljZTogbnVtYmVyO1xuICAgIHF1YW50aXR5OiBudW1iZXI7XG4gIH0+O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcmRlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlT3JkZXIob3JkZXJEYXRhOiBDcmVhdGVPcmRlckRhdGEpOiBQcm9taXNlPE9yZGVyPiB7XG4gIGNvbnN0IHN1YnRvdGFsID0gb3JkZXJEYXRhLml0ZW1zLnJlZHVjZShcbiAgICAoc3VtLCBpdGVtKSA9PiBzdW0gKyBpdGVtLnByb2R1Y3RQcmljZSAqIGl0ZW0ucXVhbnRpdHksXG4gICAgMCxcbiAgKTtcbiAgY29uc3QgZGVsaXZlcnlGZWUgPVxuICAgIHN1YnRvdGFsID49IERFTElWRVJZX0NPTkZJRy5mcmVlRGVsaXZlcnlUaHJlc2hvbGRcbiAgICAgID8gMFxuICAgICAgOiBERUxJVkVSWV9DT05GSUcuYmFzZUZlZTtcbiAgY29uc3QgdG90YWwgPSBzdWJ0b3RhbCArIGRlbGl2ZXJ5RmVlO1xuXG4gIGxldCBvcmRlcjogT3JkZXI7XG5cbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCgpKSB7XG4gICAgLy8gUmV0dXJuIG1vY2sgb3JkZXJcbiAgICBjb25zdCBvcmRlck51bWJlciA9IGBTUy0ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgyLCAxMCkucmVwbGFjZSgvLS9nLCBcIlwiKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNikudG9VcHBlckNhc2UoKX1gO1xuXG4gICAgb3JkZXIgPSB7XG4gICAgICBpZDogYG9yZGVyLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgb3JkZXJfbnVtYmVyOiBvcmRlck51bWJlcixcbiAgICAgIGN1c3RvbWVyX25hbWU6IG9yZGVyRGF0YS5jdXN0b21lci5uYW1lLFxuICAgICAgY3VzdG9tZXJfcGhvbmU6IG9yZGVyRGF0YS5jdXN0b21lci5waG9uZSxcbiAgICAgIGN1c3RvbWVyX2FkZHJlc3M6IG9yZGVyRGF0YS5jdXN0b21lci5hZGRyZXNzLFxuICAgICAgY3VzdG9tZXJfbm90ZXM6IG9yZGVyRGF0YS5jdXN0b21lci5ub3RlcyxcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICBzdWJ0b3RhbCxcbiAgICAgIGRlbGl2ZXJ5X2ZlZTogZGVsaXZlcnlGZWUsXG4gICAgICB0b3RhbCxcbiAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgb3JkZXJcbiAgICAgIGNvbnN0IHsgZGF0YTogb3JkZXJEYXRhMiwgZXJyb3I6IG9yZGVyRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKFwib3JkZXJzXCIpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIGN1c3RvbWVyX25hbWU6IG9yZGVyRGF0YS5jdXN0b21lci5uYW1lLFxuICAgICAgICAgIGN1c3RvbWVyX3Bob25lOiBvcmRlckRhdGEuY3VzdG9tZXIucGhvbmUsXG4gICAgICAgICAgY3VzdG9tZXJfYWRkcmVzczogb3JkZXJEYXRhLmN1c3RvbWVyLmFkZHJlc3MsXG4gICAgICAgICAgY3VzdG9tZXJfbm90ZXM6IG9yZGVyRGF0YS5jdXN0b21lci5ub3RlcyxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHN1YnRvdGFsLFxuICAgICAgICAgIGRlbGl2ZXJ5X2ZlZTogZGVsaXZlcnlGZWUsXG4gICAgICAgICAgdG90YWwsXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgIGlmIChvcmRlckVycm9yKSB0aHJvdyBvcmRlckVycm9yO1xuXG4gICAgICBvcmRlciA9IG9yZGVyRGF0YTIgYXMgT3JkZXI7XG5cbiAgICAgIC8vIENyZWF0ZSBvcmRlciBpdGVtc1xuICAgICAgY29uc3Qgb3JkZXJJdGVtcyA9IG9yZGVyRGF0YS5pdGVtcy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICAgIG9yZGVyX2lkOiBvcmRlci5pZCxcbiAgICAgICAgcHJvZHVjdF9pZDogaXRlbS5wcm9kdWN0SWQsXG4gICAgICAgIHByb2R1Y3RfbmFtZTogaXRlbS5wcm9kdWN0TmFtZSxcbiAgICAgICAgcHJvZHVjdF9wcmljZTogaXRlbS5wcm9kdWN0UHJpY2UsXG4gICAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5LFxuICAgICAgICBzdWJ0b3RhbDogaXRlbS5wcm9kdWN0UHJpY2UgKiBpdGVtLnF1YW50aXR5LFxuICAgICAgfSkpO1xuXG4gICAgICBjb25zdCB7IGVycm9yOiBpdGVtc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbShcIm9yZGVyX2l0ZW1zXCIpXG4gICAgICAgIC5pbnNlcnQob3JkZXJJdGVtcyk7XG5cbiAgICAgIGlmIChpdGVtc0Vycm9yKSB0aHJvdyBpdGVtc0Vycm9yO1xuXG4gICAgICAvLyBDcmVhdGUgcGF5bWVudCByZWNvcmRcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHBheW1lbnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInBheW1lbnRzXCIpLmluc2VydCh7XG4gICAgICAgIG9yZGVyX2lkOiBvcmRlci5pZCxcbiAgICAgICAgbWV0aG9kOiBvcmRlckRhdGEucGF5bWVudE1ldGhvZCxcbiAgICAgICAgc3RhdHVzOiBvcmRlckRhdGEucGF5bWVudE1ldGhvZCA9PT0gXCJjb2RcIiA/IFwicGVuZGluZ1wiIDogXCJwZW5kaW5nXCIsXG4gICAgICAgIGFtb3VudDogdG90YWwsXG4gICAgICAgIHJlZmVyZW5jZV9udW1iZXI6IG9yZGVyRGF0YS5nY2FzaFJlZmVyZW5jZSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocGF5bWVudEVycm9yKSB0aHJvdyBwYXltZW50RXJyb3I7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyBvcmRlcjpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gU2VuZCBlbWFpbCBub3RpZmljYXRpb24gKG5vbi1ibG9ja2luZylcbiAgc2VuZE9yZGVyTm90aWZpY2F0aW9uKHtcbiAgICBvcmRlck51bWJlcjogb3JkZXIub3JkZXJfbnVtYmVyLFxuICAgIGN1c3RvbWVyTmFtZTogb3JkZXJEYXRhLmN1c3RvbWVyLm5hbWUsXG4gICAgY3VzdG9tZXJQaG9uZTogb3JkZXJEYXRhLmN1c3RvbWVyLnBob25lLFxuICAgIGN1c3RvbWVyQWRkcmVzczogb3JkZXJEYXRhLmN1c3RvbWVyLmFkZHJlc3MsXG4gICAgY3VzdG9tZXJOb3Rlczogb3JkZXJEYXRhLmN1c3RvbWVyLm5vdGVzLFxuICAgIGl0ZW1zOiBvcmRlckRhdGEuaXRlbXMubWFwKChpdGVtKSA9PiAoe1xuICAgICAgbmFtZTogaXRlbS5wcm9kdWN0TmFtZSxcbiAgICAgIHByaWNlOiBpdGVtLnByb2R1Y3RQcmljZSxcbiAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5LFxuICAgIH0pKSxcbiAgICBzdWJ0b3RhbCxcbiAgICBkZWxpdmVyeUZlZSxcbiAgICB0b3RhbCxcbiAgICBwYXltZW50TWV0aG9kOiBvcmRlckRhdGEucGF5bWVudE1ldGhvZCxcbiAgICBnY2FzaFJlZmVyZW5jZTogb3JkZXJEYXRhLmdjYXNoUmVmZXJlbmNlLFxuICB9KS5jYXRjaCgoZXJyKSA9PiBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgbm90aWZpY2F0aW9uOlwiLCBlcnIpKTtcblxuICByZXR1cm4gb3JkZXI7XG59XG5cbi8qKlxuICogU2VuZCBvcmRlciBub3RpZmljYXRpb24gZW1haWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZE9yZGVyTm90aWZpY2F0aW9uKGRhdGE6IHtcbiAgb3JkZXJOdW1iZXI6IHN0cmluZztcbiAgY3VzdG9tZXJOYW1lOiBzdHJpbmc7XG4gIGN1c3RvbWVyUGhvbmU6IHN0cmluZztcbiAgY3VzdG9tZXJBZGRyZXNzOiBzdHJpbmc7XG4gIGN1c3RvbWVyTm90ZXM/OiBzdHJpbmc7XG4gIGl0ZW1zOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgcHJpY2U6IG51bWJlcjsgcXVhbnRpdHk6IG51bWJlciB9PjtcbiAgc3VidG90YWw6IG51bWJlcjtcbiAgZGVsaXZlcnlGZWU6IG51bWJlcjtcbiAgdG90YWw6IG51bWJlcjtcbiAgcGF5bWVudE1ldGhvZDogc3RyaW5nO1xuICBnY2FzaFJlZmVyZW5jZT86IHN0cmluZztcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS9zZW5kLW9yZGVyLW5vdGlmaWNhdGlvblwiLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gc2VuZCBub3RpZmljYXRpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiTm90aWZpY2F0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb3JkZXIgYnkgb3JkZXIgbnVtYmVyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcmRlckJ5TnVtYmVyKFxuICBvcmRlck51bWJlcjogc3RyaW5nLFxuKTogUHJvbWlzZTxPcmRlciB8IG51bGw+IHtcbiAgaWYgKCFpc1N1cGFiYXNlQ29uZmlndXJlZCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcIm9yZGVyc1wiKVxuICAgICAgLnNlbGVjdChcbiAgICAgICAgYFxuICAgICAgICAqLFxuICAgICAgICBpdGVtczpvcmRlcl9pdGVtcygqKSxcbiAgICAgICAgcGF5bWVudDpwYXltZW50cygqKVxuICAgICAgYCxcbiAgICAgIClcbiAgICAgIC5lcShcIm9yZGVyX251bWJlclwiLCBvcmRlck51bWJlcilcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGEgYXMgT3JkZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIG9yZGVyOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdXNlcidzIG9yZGVyc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlck9yZGVycyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8T3JkZXJbXT4ge1xuICBpZiAoIWlzU3VwYWJhc2VDb25maWd1cmVkKCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcIm9yZGVyc1wiKVxuICAgICAgLnNlbGVjdChcbiAgICAgICAgYFxuICAgICAgICAqLFxuICAgICAgICBpdGVtczpvcmRlcl9pdGVtcygqKSxcbiAgICAgICAgcGF5bWVudDpwYXltZW50cygqKVxuICAgICAgYCxcbiAgICAgIClcbiAgICAgIC5lcShcInVzZXJfaWRcIiwgdXNlcklkKVxuICAgICAgLm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIHJldHVybiAoZGF0YSB8fCBbXSkgYXMgT3JkZXJbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBvcmRlcnM6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsImlzU3VwYWJhc2VDb25maWd1cmVkIiwiQ0FURUdPUklFUyIsIkRFTElWRVJZX0NPTkZJRyIsIm1vY2tDYXRlZ29yaWVzIiwibWFwIiwiY2F0IiwiaW5kZXgiLCJpZCIsIm5hbWUiLCJzbHVnIiwiaWNvbiIsIml0ZW1fY291bnQiLCJpdGVtQ291bnQiLCJzb3J0X29yZGVyIiwiaXNfYWN0aXZlIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInVwZGF0ZWRfYXQiLCJnZXRDYXRlZ29yaWVzIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJjYXRlZ29yaWVzV2l0aENvdW50IiwiUHJvbWlzZSIsImFsbCIsImNvdW50IiwiaGVhZCIsImNvbnNvbGUiLCJnZXRDYXRlZ29yeUJ5U2x1ZyIsImZpbmQiLCJzaW5nbGUiLCJnZXRQcm9kdWN0cyIsImZpbHRlcnMiLCJmaWx0ZXJNb2NrUHJvZHVjdHMiLCJxdWVyeSIsImNhdGVnb3J5U2x1ZyIsImNhdGVnb3J5Iiwic2VhcmNoIiwiaWxpa2UiLCJpc0F2YWlsYWJsZSIsInVuZGVmaW5lZCIsImlzRmVhdHVyZWQiLCJiYWRnZSIsIm1pblByaWNlIiwiZ3RlIiwibWF4UHJpY2UiLCJsdGUiLCJzb3J0QnkiLCJhc2NlbmRpbmciLCJudWxsc0ZpcnN0IiwibGltaXQiLCJvZmZzZXQiLCJyYW5nZSIsInByb2R1Y3RzIiwibW9ja1Byb2R1Y3RzIiwiY2F0ZWdvcnlJbmRleCIsImZpbmRJbmRleCIsImZpbHRlciIsInAiLCJjYXRlZ29yeV9pZCIsInNlYXJjaExvd2VyIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImlzX2F2YWlsYWJsZSIsImlzX2ZlYXR1cmVkIiwic29ydCIsImEiLCJiIiwicHJpY2UiLCJsb2NhbGVDb21wYXJlIiwicmF0aW5nIiwic2xpY2UiLCJnZXRQcm9kdWN0QnlTbHVnIiwic2VhcmNoUHJvZHVjdHMiLCJnZXRGZWF0dXJlZFByb2R1Y3RzIiwiZ2V0RGFpbHlCZXN0U2VsbGVycyIsImluIiwiZ2V0VG9wUHJvZHVjdHMiLCJzb3J0ZWRCeVJhdGluZyIsInNvcnRlZEJ5UmV2aWV3cyIsInJldmlld19jb3VudCIsInRvcFNlbGxzIiwidG9wUmF0ZWQiLCJ0cmVuZGluZyIsInJlY2VudGx5QWRkZWQiLCJjcmVhdGVPcmRlciIsIm9yZGVyRGF0YSIsInN1YnRvdGFsIiwiaXRlbXMiLCJyZWR1Y2UiLCJzdW0iLCJpdGVtIiwicHJvZHVjdFByaWNlIiwicXVhbnRpdHkiLCJkZWxpdmVyeUZlZSIsImZyZWVEZWxpdmVyeVRocmVzaG9sZCIsImJhc2VGZWUiLCJ0b3RhbCIsIm9yZGVyTnVtYmVyIiwiTWF0aCIsInJlcGxhY2UiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInRvVXBwZXJDYXNlIiwibm93Iiwib3JkZXJfbnVtYmVyIiwiY3VzdG9tZXJfbmFtZSIsImN1c3RvbWVyIiwiY3VzdG9tZXJfcGhvbmUiLCJwaG9uZSIsImN1c3RvbWVyX2FkZHJlc3MiLCJhZGRyZXNzIiwiY3VzdG9tZXJfbm90ZXMiLCJub3RlcyIsInN0YXR1cyIsImRlbGl2ZXJ5X2ZlZSIsIm9yZGVyRGF0YTIiLCJvcmRlckVycm9yIiwiaW5zZXJ0Iiwib3JkZXJJdGVtcyIsIm9yZGVyX2lkIiwicHJvZHVjdF9pZCIsInByb2R1Y3RJZCIsInByb2R1Y3RfbmFtZSIsInByb2R1Y3ROYW1lIiwicHJvZHVjdF9wcmljZSIsIml0ZW1zRXJyb3IiLCJwYXltZW50RXJyb3IiLCJtZXRob2QiLCJwYXltZW50TWV0aG9kIiwiYW1vdW50IiwicmVmZXJlbmNlX251bWJlciIsImdjYXNoUmVmZXJlbmNlIiwic2VuZE9yZGVyTm90aWZpY2F0aW9uIiwiY3VzdG9tZXJOYW1lIiwiY3VzdG9tZXJQaG9uZSIsImN1c3RvbWVyQWRkcmVzcyIsImN1c3RvbWVyTm90ZXMiLCJjYXRjaCIsImVyciIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsIkVycm9yIiwianNvbiIsImdldE9yZGVyQnlOdW1iZXIiLCJnZXRVc2VyT3JkZXJzIiwidXNlcklkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});